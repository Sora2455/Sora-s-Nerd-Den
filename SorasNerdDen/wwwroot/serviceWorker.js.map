{"version":3,"sources":["serviceWorker.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"serviceWorker.js","sourcesContent":["var log = console.log.bind(console);\nvar err = console.error.bind(console);\nonerror = err;\n// Moves the contents of one named cached into another.\nfunction cacheCopy(source, destination) {\n    \"use strict\";\n    return caches.delete(destination).then(function () {\n        return Promise.all([\n            caches.open(source),\n            caches.open(destination)\n        ]).then(function (results) {\n            var sourceCache = results[0];\n            var destCache = results[1];\n            return sourceCache.keys().then(function (requests) {\n                return Promise.all(requests.map(function (request) {\n                    return sourceCache.match(request).then(function (response) {\n                        return destCache.put(request, response);\n                    });\n                }));\n            });\n        });\n    });\n}\nfunction fetchAndCache(request, cache) {\n    \"use strict\";\n    if (!(request instanceof Request)) {\n        request = new Request(request);\n    }\n    return fetch(request.clone()).then(function (response) {\n        // if the response came back not okay (like a server error) try and get from cache\n        if (!response.ok) {\n            return cache.match(request);\n        }\n        // otherwise store the response for future use, and return the response to the client\n        cache.put(request, response.clone());\n        return response;\n    }).catch(function () {\n        // if there was an error (almost certainly network touble) try and get from cache\n        return cache.match(request);\n    });\n}\naddEventListener(\"install\", function (e) {\n    \"use strict\";\n    // Put updated resources in a new cache, so that currently running pages\n    // get the current versions.\n    e.waitUntil(caches.delete(\"core-waiting\").then(function () {\n        return caches.open(\"core-waiting\").then(function (core) {\n            var resourceUrls = [\n                \"/loading/\",\n                // ?v=m means without the shared view (just the main content)\n                \"/?v=m\",\n                \"/offline/?v=m\",\n                \"/css/site.css\",\n                \"/css/font-awesome.css\",\n                \"/js/jquery.js\",\n                \"/js/bootstrap.js\",\n                \"/js/site.js\"\n            ];\n            return Promise.all(resourceUrls.map(function (key) {\n                // Make sure to download fresh versions of the files!\n                return fetch(key, { cache: \"no-cache\" })\n                    .then(function (response) { return core.put(key, response); });\n            }))\n                .then(function () { return self.skipWaiting(); });\n        });\n    }));\n});\naddEventListener(\"activate\", function (e) {\n    \"use strict\";\n    // Copy the newly installed cache to the active cache\n    e.waitUntil(cacheCopy(\"core-waiting\", \"core\")\n        .then(function () { return self.clients.claim(); })\n        .then(function () { return caches.delete(\"core-waiting\"); }));\n});\naddEventListener(\"fetch\", function (e) {\n    \"use strict\";\n    var request = e.request;\n    // If not a GET request, don't cache\n    if (request.method !== \"GET\") {\n        return fetch(request);\n    }\n    // If it's a 'main' page, use the loading page instead\n    if (request.url.endsWith(\"/\")) {\n        e.respondWith(caches.open(\"core\").then(function (core) {\n            // Get the loading page\n            return fetchAndCache(\"/loading/\", core);\n        }));\n        return;\n    }\n    // TODO filter requests\n    // Basic read-through caching.\n    e.respondWith(caches.open(\"core\").then(function (core) {\n        return core.match(request).then(function (response) {\n            if (response) {\n                return response;\n            }\n            // we didn't have it in the cache, so add it to the cache and return it\n            log(\"runtime caching:\", request.url);\n            // delete any previous versions that might be in the cache already\n            core.delete(request, { ignoreSearch: true });\n            // now grab the file and add it to the cache\n            return fetchAndCache(request, core); //TODO but what if user is offline on the second time? need site.js?v=1 and only have site.js...\n        });\n    }));\n});\n"]}